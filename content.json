{"meta":{"title":"好好学习，天天摸鱼","subtitle":"摸鱼使我精疲力尽","description":"这是一个日常划水的辣鸡前端博客","author":"咸鱼蔡小胖","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"你不知道的JavaScript(中卷)笔记(一)","slug":"你不知道的JavaScript-中卷-笔记-一","date":"2018-06-27T13:25:22.000Z","updated":"2018-06-27T15:18:51.921Z","comments":true,"path":"2018/06/27/你不知道的JavaScript-中卷-笔记-一/","link":"","permalink":"http://yoursite.com/2018/06/27/你不知道的JavaScript-中卷-笔记-一/","excerpt":"","text":"最近在匆匆看了`webpack@4.0文档之后，又被《你不知道的JavaScript》吸引了目光。这本书针对JavaScript`中存在的一些容易出错的地方进行解答，可以夯实自己的基础。 类型 JavaScript有七种内置类型，包括null undefined number string boolean object和symbol(ES6) JavaScript的变量是没有类型的，有类型的是值。但变量持有值的类型。类型定义了值的行为特征 undefined表示声明后但未赋值的，undeclared表示未声明的。这两者有稍微的区别，但在JavaScript中并未区分 我们可以通过typeof指令来确定值的类型 ![示例](https://s1.ax1x.com/2018/06/27/Pi9Sit.png) 可以很清楚的发现通过typeof指令能得到大多数值的类型，然而这里没有出现null object相关代码。这是因为typeof null的结果也是object，这是JavaScript设计的错误，所以如果想判断是否类型为null,可以通过 1!a&amp;&amp;typeof a === &apos;object&apos; 我们可以使用typeof指令来检查undeclared变量，因为typeof有安全防范机制（阻止报错）&lt;!- -more- -&gt; 值 数组(array)、字符串(string)、数字(number)是JavaScript的程序基本组成部分，但在使用过程中，还是有一些坑 数组 相对于其他强类型语言来说，JavaScript中的数组是不用事先声明数组容量和类型的，所以数组可以容纳任意类型的值 可以使用delete运算符删除数组中的元素，但数组的长度并不会减少 数组是通过数字索引来获取值的，但由于数组同样是对象，所以可以通过对象的方式获取值1234567var a = []a[0] = 1a[&apos;today&apos;] = &apos;sunday&apos;a.length // 1a[&apos;today] // &apos;sunday&apos;a.today // &apos;sunday&apos; 这里有两点要注意的是，使用字符串键值来赋值的话，数组的长度并不会增加；如果字符串键值是可以被强制转换为数字的值的话，会被当做数字索引来处理123a[&apos;2018&apos;] = 2018a[&apos;2018&apos;] // 2018a[2018] //2018 所以通过数组来存放字符串键值/属性并不是很合适的做法，应该使用对象 类数组 类数组是具有数组的某种特性（可以通过数字索引）的值，我们可以通过某些方式，例如slice,concat等数组工具函数来实现将其转换为真正的数组 如上图的两种方法，都可以将类数组转换为真正的数组 字符串 字符串和数组很相似，都由length属性以及indexOf()、concat()方法，但字符串不等于字符数组 字符串是不可变的，而数组是可变的。这里指的不可变是字符串的原始成员不会被改变值，而是会创建并返回一个新的字符串 字符串和数组可以通过函数进行相互的处理，这在某些时候是很方便的 数字 JavaScript只有一种数值类型：数字(number)，包括整数以及带小数的十进制数。 可以使用toFixed保留小数部分位数(但有坑) 112.toFixed(3) //SyntaxError 如果直接使用值去调用数值方法，将会报错，因为解析的时候会认为12.是整体，可以通过以下方法调用数值方法 NaN值Not a Number即不是数值，NaN不等于NaN null值空值，undefined值没有值 0值包括+0和-0值和引用 JavaScript中值的几种类型，在实际的赋值和参数传递中，分为值传递和引用传递 值传递是指直接复制指的方法进行赋值，简单类型的赋值都是值传递 引用传递是指将复杂类型值的存储地址赋给变量，这样相当于两者共享一个空间，都可对该地址的值做出更改，并会影响对方","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/基础知识/"}]},{"title":"webpack建立开发环境","slug":"webpack建立开发环境","date":"2018-06-25T12:27:00.000Z","updated":"2018-06-27T15:18:59.998Z","comments":true,"path":"2018/06/25/webpack建立开发环境/","link":"","permalink":"http://yoursite.com/2018/06/25/webpack建立开发环境/","excerpt":"","text":"webpack的强大在开发中能够得到更直白的体现，学习使用Webpack搭建开发环境，能够让开发更简单一些 使用source map webpack能够打包我们的代码，虽然使用起来很方便，但在排除错误时，只会指向我们打包生成的bundle.js，很难定位到相应的准确位置。使用source map,能够跟踪错误的警告信息。source map有许多配置信息，可以仔细查阅webpack.config.js123456789101112131415161718192021const path = require(&apos;path&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)module.exports = &#123; entry: &#123; app: &apos;./src/index.js&apos;, print: &apos;./src/print.js&apos; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;Output Management&apos; &#125;), new CleanWebpackPlugin([&apos;dist&apos;]) ], output: &#123; filename: &apos;[name].bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, devtool: &apos;inline-cheap-module-source-map&apos;&#125; 在devtool字段中写入对应的source map选项，实现不同的调试效果&lt;!- -more- -&gt; 使用观察模式 在使用webpack打包之后，如果修改了依赖文件内容，程序并不会主动做出修改，需要我们重新进行打包，这当然是繁琐的，所以可以使用webpack自带的观察模式，即使用wepack &quot;watch&quot;监听文件 可以在package.json文件的script脚本命令中添加启动webpack观察模式的命令：1&quot;watch&quot;: &quot;webpack --watch&quot;, 当我们在命令行中运行npm run watch命令之后，可以看到webopack在编译代码，但不会退出，当我们修改了我们的代码之后，保存，webpack会自动重新编译修改后的模块 使用webpack-dev-server index.html虽然可以双击直接运行，但肯定不如在服务器上运行来得便捷，可以使用live-server来构建一个本地服务器。但在webpack中我们也可以配置webpack-dev-server来构建简单的web服务器，而且能够实现实时重新加载。 123devServer: &#123; contentBase: &apos;./dist/&apos; &#125; 以上配置告知webpack-dev-server，在localhost:8080下建立服务，将dist目录下的文件，作为可访问的文件在package.json文件中配置脚本命令，可以直接运行开发服务器123456&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;start&quot;: &quot;webpack-dev-server --open&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;,","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"开发环境","slug":"开发环境","permalink":"http://yoursite.com/tags/开发环境/"}]},{"title":"初识webpack@4.0","slug":"初识webpack-4-0","date":"2018-06-24T09:17:28.000Z","updated":"2018-06-27T15:18:34.374Z","comments":true,"path":"2018/06/24/初识webpack-4-0/","link":"","permalink":"http://yoursite.com/2018/06/24/初识webpack-4-0/","excerpt":"","text":"webpack webpack 是一个现代 JavaScript应用程序的静态模块打包器，当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack的四个核心概念入口(entry)入口起点标明了webpack应该使用哪个模块，从哪个文件作为构建依赖包的开始可以在webpack.config.js中的entry配置简单入口123module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;; 当然也可以传入一个数组，这会创建多个主入口出口指明webpack在哪里输出他所创建的bundles，以及如何对文件命名，默认值为./dist123456789const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;&#125;; 上面的代码简单的表示了output的作用，通过path,filename对输出的文件进行路径以及名称的设置&lt;!- -more- -&gt; loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。所以可以通过引入各种loader实现我们打包不同类型文件的目的1234567891011121314const path = require(&apos;path&apos;);const config = &#123; output: &#123; filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;&#125;;module.exports = config; 上述代码即表示了loader的两个重要属性值 test: 用于标识出应该被对应的 loader 进行转换的某个或某些文件 use: 用于转换时，确定使用哪种loader 插件(plugins)loader被用来转换各类模块，而插件能实现更强大、范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。12345678910111213141516const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装const webpack = require(&apos;webpack&apos;); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /\\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;) ]&#125;;module.exports = config; 插件的功能很强大，而能被使用的插件种类也很丰富，许多开箱即用的插件都在插件列表中可以看到。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/tags/前端工具/"}]}]}