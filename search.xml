<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>你不知道的JavaScript(中卷)笔记(二)</title>
      <link href="/2018/06/28/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%AD%E5%8D%B7-%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2018/06/28/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%AD%E5%8D%B7-%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><blockquote><p>众所周知，<code>JavaScript</code>是弱类型语言，所以其值的类型是可以随意进行转换的，分为显式强制类型转换和隐式强制类型转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let b = 12</span><br><span class="line">let a = &apos;&apos; + b // 隐式强制类型转换</span><br><span class="line">let c = String(b) //显式强制类型转换</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h3><blockquote><p>熟悉<code>toString</code>,<code>toNumber</code>,<code>toBoolean</code>，完成数值、字符串、布尔值互相的转换<br><a id="more"></a></p></blockquote><h4 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a><code>ToString</code></h4><blockquote><p>基本类型值的字符串化规则是: <code>undefined</code>转换为<code>&#39;undefined&#39;</code>，<code>null</code>转换为<code>&#39;null&#39;</code>，<code>true</code>转换为<code>&#39;true&#39;</code>，这些都能通过<code>toString</code>完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;</span><br><span class="line">a.toString() // &quot;1.07e21&quot;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>对普通对象来说，只要不是自行定义，否则<code>toString</code>返回其内部 属性<code>[[Class]]</code>的值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3]</span><br><span class="line">a.toString() // &apos;1,2,3&apos;</span><br></pre></td></tr></table></figure><h4 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a><code>ToNumber</code></h4><blockquote><p>使用<code>toNumber</code>将非数字值转换为数字使用，包括<code>true</code>转为<code>1</code>，<code>false</code>转为<code>0</code>等</p></blockquote><h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a><code>ToBoolean</code></h4><blockquote><p><code>JavaScript</code>的值可分为可以被强制类型转换为<code>false</code>的值和其他值，而这部分能被转换的值称为假值</p></blockquote><p>假值包括有</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>+0</code>, <code>-0</code>和<code>NaN</code></li><li><code>&quot;&quot;</code></li></ul><p>我们可以理解为假值以外的值都是真值，真值转换为布尔值都为<code>true</code></p><h4 id="假值对象"><a href="#假值对象" class="headerlink" title="假值对象"></a>假值对象</h4><blockquote><p>假值对象并不是对象为假值，而是进行对象封装的假值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = new Boolean(false)</span><br><span class="line">let b = new Number(0)</span><br><span class="line">let c = new String(&quot;&quot;)</span><br></pre></td></tr></table></figure><p>上面大的即为假值对象，虽然他们都封装了假值，然而他们并不是<code>false</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let d = Boolean(a &amp;&amp; b &amp;&amp; c)</span><br><span class="line">d //true</span><br></pre></td></tr></table></figure></p><h3 id="显示强制类型转换"><a href="#显示强制类型转换" class="headerlink" title="显示强制类型转换"></a>显示强制类型转换</h3><blockquote><p>显示强制类型即是显而易见的类型转换，包括<code>toString</code>,<code>toNumber</code>等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = &apos;12&apos;</span><br><span class="line">+a // 12</span><br></pre></td></tr></table></figure></p></blockquote><p>这里的一元运算符<code>+</code>即可将字符串显示强制转换为数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let b = &apos;&apos;</span><br><span class="line">!!b // false</span><br></pre></td></tr></table></figure></p><p>这里的<code>!!</code>即可将值显示强制转换为布尔值</p><h3 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h3><blockquote><p>隐式强制转换往往带来很多误解和<code>bug</code></p></blockquote><p>针对<code>+</code>号，如果 <code>+</code> 的其中一个操作数是字符串（或者通过以上步骤可以得到字符串），则执行字符串拼接；否则执行数字加法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 42; </span><br><span class="line">var b = &quot;abc&quot;; </span><br><span class="line">var c = null; </span><br><span class="line">a || b;     // 42 </span><br><span class="line">a &amp;&amp; b;     // &quot;abc&quot; </span><br><span class="line">c || b;     // &quot;abc&quot;</span><br><span class="line">c &amp;&amp; b;     // null</span><br></pre></td></tr></table></figure><ul><li><p><code>||</code> 和 <code>&amp;&amp;</code> 首先会对第一个操作数 第一个操作数 （a 和 c ）执行条件判断，如果其不是布尔值（如上例）就先进行 <code>ToBoolean</code>强制类型转 换，然后再执行条件判断。</p></li><li><p>对于<code>||</code> 来说，如果条件判断结果为 <code>true</code> 就返回第一个操作数（a 和 c ）的值，如果为 <code>false</code> 就返回第二个操作数（b ） 的值。</p></li><li><code>&amp;&amp;</code>则相反，如果条件判断结果为 <code>true</code> 就返回第二个操作数（b ）的值，如果为 <code>false</code> 就返回第一个操作数（a 和 c ）的 值。 </li></ul><h3 id="宽松相等-和严格相等"><a href="#宽松相等-和严格相等" class="headerlink" title="宽松相等(==)和严格相等(===)"></a>宽松相等(<code>==</code>)和严格相等(<code>===</code>)</h3><blockquote><p><code>==</code> 和 <code>===</code> 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 42; </span><br><span class="line">var b = &quot;42&quot;; </span><br><span class="line"></span><br><span class="line">a === b;    // false </span><br><span class="line">a == b;     // true</span><br></pre></td></tr></table></figure></p></blockquote><p>具体转换规则为</p><blockquote><p>(1) 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。<br>(2) 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。</p></blockquote><h4 id="其他类型和布尔类型相等比较"><a href="#其他类型和布尔类型相等比较" class="headerlink" title="其他类型和布尔类型相等比较"></a>其他类型和布尔类型相等比较</h4><p>规则如下</p><blockquote><p>(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；<br>(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</p></blockquote><h4 id="null和undefined之间相等比较"><a href="#null和undefined之间相等比较" class="headerlink" title="null和undefined之间相等比较"></a><code>null</code>和<code>undefined</code>之间相等比较</h4><blockquote><p>(1) 如果 x 为 null ，y 为 undefined ，则结果为 true 。<br>(2) 如果 x 为 undefined ，y 为 null ，则结果为 true </p></blockquote><h4 id="对象与非对象之间的相等比较"><a href="#对象与非对象之间的相等比较" class="headerlink" title="对象与非对象之间的相等比较"></a>对象与非对象之间的相等比较</h4><blockquote><p>(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；<br>(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p></blockquote>]]></content>
      
      <categories>
          
          <category> JavaScript，你不知道的JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的JavaScript(中卷)笔记(一)</title>
      <link href="/2018/06/27/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%AD%E5%8D%B7-%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2018/06/27/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%AD%E5%8D%B7-%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      <content type="html"><![CDATA[<blockquote><p>最近在匆匆看了<a href="mailto:`webpack@4.0" target="_blank" rel="noopener">`webpack@4.0</a><code>文档之后，又被</code>《你不知道的JavaScript》<code>吸引了目光。这本书针对</code>JavaScript`中存在的一些容易出错的地方进行解答，可以夯实自己的基础。</p></blockquote><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><blockquote><p><code>JavaScript</code>有七种内置类型，包括<code>null</code> <code>undefined</code> <code>number</code> <code>string</code> <code>boolean</code> <code>object</code>和<code>symbol</code>(ES6)</p></blockquote><ol><li><code>JavaScript</code>的变量是没有类型的，有类型的是值。但变量持有值的类型。类型定义了值的行为特征</li><li><code>undefined</code>表示声明后但未赋值的，<code>undeclared</code>表示未声明的。这两者有稍微的区别，但在<code>JavaScript</code>中并未区分<a id="more"></a></li><li><p>我们可以通过<code>typeof</code>指令来确定值的类型<br><img src="https://s1.ax1x.com/2018/06/27/Pi9Sit.png" alt="示例"><br>可以很清楚的发现通过<code>typeof</code>指令能得到大多数值的类型，然而这里没有出现<code>null</code> <code>object</code>相关代码。这是因为<code>typeof null</code>的结果也是<code>object</code>，这是<code>JavaScript</code>设计的错误，所以如果想判断是否类型为<code>null</code>,可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!a&amp;&amp;typeof a === &apos;object&apos;</span><br></pre></td></tr></table></figure></li><li><p>我们可以使用<code>typeof</code>指令来检查<code>undeclared</code>变量，因为<code>typeof</code>有安全防范机制（阻止报错）</p></li></ol><h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><blockquote><p>数组(<code>array</code>)、字符串(<code>string</code>)、数字(<code>number</code>)是<code>JavaScript</code>的程序基本组成部分，但在使用过程中，还是有一些坑</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>相对于其他强类型语言来说，<code>JavaScript</code>中的数组是不用事先声明数组容量和类型的，所以数组可以容纳任意类型的值</p></blockquote><ol><li>可以使用<code>delete</code>运算符删除数组中的元素，但数组的长度并不会减少</li><li>数组是通过数字索引来获取值的，但由于数组同样是对象，所以可以通过对象的方式获取值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = []</span><br><span class="line">a[0] = 1</span><br><span class="line">a[&apos;today&apos;] = &apos;sunday&apos;</span><br><span class="line"></span><br><span class="line">a.length // 1</span><br><span class="line">a[&apos;today] // &apos;sunday&apos;</span><br><span class="line">a.today // &apos;sunday&apos;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这里有两点要注意的是，使用字符串键值来赋值的话，数组的长度并不会增加；如果字符串键值是可以被强制转换为数字的值的话，会被当做数字索引来处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[&apos;2018&apos;] = 2018</span><br><span class="line">a[&apos;2018&apos;] // 2018</span><br><span class="line">a[2018] //2018</span><br></pre></td></tr></table></figure></p></blockquote><p>所以通过数组来存放字符串键值/属性并不是很合适的做法，应该使用对象</p><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h4><blockquote><p>类数组是具有数组的某种特性（可以通过数字索引）的值，我们可以通过某些方式，例如<code>slice</code>,<code>concat</code>等数组工具函数来实现将其转换为真正的数组</p></blockquote><p><img src="https://s1.ax1x.com/2018/06/27/PiC49x.png" alt="转换类数组"></p><p>如上图的两种方法，都可以将类数组转换为真正的数组</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote><p>字符串和数组很相似，都由<code>length</code>属性以及<code>indexOf()</code>、<code>concat()</code>方法，但字符串不等于字符数组</p></blockquote><ol><li>字符串是不可变的，而数组是可变的。这里指的不可变是字符串的原始成员不会被改变值，而是会创建并返回一个新的字符串<br><img src="https://s1.ax1x.com/2018/06/27/PiCOUA.png" alt="字符串不是字符数组"></li><li><p>字符串和数组可以通过函数进行相互的处理，这在某些时候是很方便的<br><img src="https://s1.ax1x.com/2018/06/27/PiParD.png" alt="字符串反转"></p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><blockquote><p><code>JavaScript</code>只有一种数值类型：数字(number)，包括整数以及带小数的十进制数。</p></blockquote></li><li><p>可以使用<code>toFixed</code>保留小数部分位数(但有坑)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12.toFixed(3) //SyntaxError</span><br></pre></td></tr></table></figure></li></ol><p>如果直接使用值去调用数值方法，将会报错，因为解析的时候会认为<code>12.</code>是整体，可以通过以下方法调用数值方法<br><img src="https://s1.ax1x.com/2018/06/27/PiP7R0.png" alt="调用数值方法"></p><ol start="2"><li><code>NaN</code>值<code>Not a Number</code>即不是数值，<code>NaN</code>不等于<code>NaN</code></li><li><code>null</code>值空值，<code>undefined</code>值没有值</li><li><code>0</code>值包括<code>+0</code>和<code>-0</code><h3 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h3><blockquote><p><code>JavaScript</code>中值的几种类型，在实际的赋值和参数传递中，分为值传递和引用传递</p></blockquote></li><li>值传递是指直接复制指的方法进行赋值，简单类型的赋值都是值传递</li><li>引用传递是指将复杂类型值的存储地址赋给变量，这样相当于两者共享一个空间，都可对该地址的值做出更改，并会影响对方</li></ol>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 你不知道的JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack建立开发环境</title>
      <link href="/2018/06/25/webpack%E5%BB%BA%E7%AB%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/06/25/webpack%E5%BB%BA%E7%AB%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<blockquote><p><code>webpack</code>的强大在开发中能够得到更直白的体现，学习使用<code>Webpack</code>搭建开发环境，能够让开发更简单一些</p></blockquote><h3 id="使用source-map"><a href="#使用source-map" class="headerlink" title="使用source map"></a>使用source map</h3><blockquote><p><code>webpack</code>能够打包我们的代码，虽然使用起来很方便，但在排除错误时，只会指向我们打包生成的<code>bundle.js</code>，很难定位到相应的准确位置。使用<code>source map</code>,能够跟踪错误的警告信息。<br><a href="https://webpack.docschina.org/configuration/devtool" target="_blank" rel="noopener">source map</a>有许多配置信息，可以仔细查阅<br><code>webpack.config.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/index.js&apos;,</span><br><span class="line">    print: &apos;./src/print.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;Output Management&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    new CleanWebpackPlugin([&apos;dist&apos;])</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: &apos;inline-cheap-module-source-map&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><p>在<code>devtool</code>字段中写入对应的<code>source map</code>选项，实现不同的调试效果<br><img src="https://s1.ax1x.com/2018/06/25/PCwaS1.png" alt="效果"></p><h3 id="使用观察模式"><a href="#使用观察模式" class="headerlink" title="使用观察模式"></a>使用观察模式</h3><blockquote><p>在使用<code>webpack</code>打包之后，如果修改了依赖文件内容，程序并不会主动做出修改，需要我们重新进行打包，这当然是繁琐的，所以可以使用<code>webpack</code>自带的观察模式，即使用<code>wepack &quot;watch&quot;</code>监听文件</p></blockquote><p>可以在<code>package.json</code>文件的<code>script</code>脚本命令中添加启动<code>webpack</code>观察模式的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;watch&quot;: &quot;webpack --watch&quot;,</span><br></pre></td></tr></table></figure></p><p>当我们在命令行中运行<code>npm run watch</code>命令之后，可以看到<code>webopack</code>在编译代码，但不会退出，当我们修改了我们的代码之后，保存，<code>webpack</code>会自动重新编译修改后的模块</p><h3 id="使用webpack-dev-server"><a href="#使用webpack-dev-server" class="headerlink" title="使用webpack-dev-server"></a>使用<code>webpack-dev-server</code></h3><blockquote><p><code>index.html</code>虽然可以双击直接运行，但肯定不如在服务器上运行来得便捷，可以使用<code>live-server</code>来构建一个本地服务器。但在<code>webpack</code>中我们也可以配置<code>webpack-dev-server</code>来构建简单的<code>web</code>服务器，而且能够实现实时重新加载。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: &apos;./dist/&apos;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上配置告知<code>webpack-dev-server</code>，在<code>localhost:8080</code>下建立服务，将<code>dist</code>目录下的文件，作为可访问的文件<br>在<code>package.json</code>文件中配置脚本命令，可以直接运行开发服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">     &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">     &quot;watch&quot;: &quot;webpack --watch&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">     &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识webpack@4.0</title>
      <link href="/2018/06/24/%E5%88%9D%E8%AF%86webpack-4-0/"/>
      <url>/2018/06/24/%E5%88%9D%E8%AF%86webpack-4-0/</url>
      <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><blockquote><p><code>webpack</code> 是一个现代 <code>JavaScript</code>应用程序的静态模块打包器，当 <code>webpack</code> 处理应用程序时，它会递归地构建一个依赖关系图(<code>dependency graph</code>)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <code>bundle</code>。</p></blockquote><h3 id="webpack的四个核心概念"><a href="#webpack的四个核心概念" class="headerlink" title="webpack的四个核心概念"></a>webpack的四个核心概念</h3><h4 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(<code>entry</code>)</h4><p>入口起点标明了<code>webpack</code>应该使用哪个模块，从哪个文件作为构建依赖包的开始<br>可以在<code>webpack.config.js</code>中的<code>entry</code>配置简单入口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>当然也可以传入一个数组，这会创建多个主入口<br>出口指明<code>webpack</code>在哪里输出他所创建的<code>bundles</code>，以及如何对文件命名，默认值为<code>./dist</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的代码简单的表示了<code>output</code>的作用，通过<code>path</code>,<code>filename</code>对输出的文件进行路径以及名称的设置</p><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a><code>loader</code></h4><p><code>loader</code> 让 <code>webpack</code> 能够去处理那些非 <code>JavaScript</code> 文件（<code>webpack</code> 自身只理解 <code>JavaScript</code>）。<code>loader</code> 可以将所有类型的文件转换为 <code>webpack</code> 能够处理的有效模块，然后你就可以利用 <code>webpack</code> 的打包能力，对它们进行处理。<br>所以可以通过引入各种<code>loader</code>实现我们打包不同类型文件的目的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></p><blockquote><p>上述代码即表示了<code>loader</code>的两个重要属性值</p><ol><li><code>test</code>: 用于标识出应该被对应的 loader 进行转换的某个或某些文件</li><li><code>use</code>: 用于转换时，确定使用哪种<code>loader</code></li></ol></blockquote><h4 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(<code>plugins</code>)</h4><p><code>loader</code>被用来转换各类模块，而插件能实现更强大、范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。<br>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装</span><br><span class="line">const webpack = require(&apos;webpack&apos;); // 用于访问内置插件</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></p><p>插件的功能很强大，而能被使用的插件种类也很丰富，许多开箱即用的插件都在<a href="https://webpack.docschina.org/plugins" target="_blank" rel="noopener">插件列表</a>中可以看到。</p>]]></content>
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
